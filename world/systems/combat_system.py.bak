# world/systems/combat_system.py
"""
战斗系统核心 - 纯NDB，不写数据库

设计原则：
1. 所有战斗状态存在ndb
2. 战斗结束后只保存结果（经验、掉落）
3. 通过插件式效果系统，加新技能不改这个文件
"""
import random
from evennia.utils import logger
from world.loaders.game_data import GAME_DATA, get_config, get_data
from world.systems.skill_effects import apply_effect

class CombatSystem:
    """战斗系统（纯逻辑类，不继承任何Evennia类）"""
    
    def __init__(self):
        """初始化战斗系统"""
        self.turn_interval = get_config('combat.turn_interval', 2.0)
        self.max_rounds = get_config('combat.max_combat_rounds', 100)
    
    def start_combat(self, attacker, target):
        """
        开始战斗
        
        Args:
            attacker: 攻击者
            target: 目标
        
        Returns:
            bool: 是否成功开始
        """
        # 检查是否已在战斗中
        if hasattr(attacker.ndb, 'in_combat') and attacker.ndb.in_combat:
            return False
        
        if hasattr(target.ndb, 'in_combat') and target.ndb.in_combat:
            return False
        
        # 初始化战斗状态
        attacker.ndb.in_combat = True
        attacker.ndb.combat_target = target
        attacker.ndb.combat_round = 0
        
        target.ndb.in_combat = True
        target.ndb.combat_target = attacker
        target.ndb.combat_round = 0
        
        logger.log_info(f"[战斗] {attacker.key} vs {target.key} 开始")
        
        return True
    
    def end_combat(self, char1, char2, winner=None):
        """
        结束战斗
        
        Args:
            char1: 角色1
            char2: 角色2
            winner: 获胜者（可选）
        """
        # 清理战斗状态
        for char in [char1, char2]:
            if hasattr(char.ndb, 'in_combat'):
                char.ndb.in_combat = False
            if hasattr(char.ndb, 'combat_target'):
                del char.ndb.combat_target
            if hasattr(char.ndb, 'combat_round'):
                del char.ndb.combat_round
            
            # 清理临时buff/debuff
            if hasattr(char.ndb, 'buffs'):
                char.ndb.buffs = []
            if hasattr(char.ndb, 'debuffs'):
                char.ndb.debuffs = []
            if hasattr(char.ndb, 'dots'):
                char.ndb.dots = []
        
        logger.log_info(f"[战斗] {char1.key} vs {char2.key} 结束")
    
    def use_skill(self, attacker, target, skill_key):
        """
        使用技能
        
        Args:
            attacker: 攻击者
            target: 目标
            skill_key: 技能ID
        
        Returns:
            list: 效果结果列表
        """
        # 获取技能数据
        skill_data = get_data('skills', skill_key)
        
        if not skill_data:
            return [{
                'type': 'error',
                'message': f'技能不存在: {skill_key}'
            }]
        
        # 检查消耗
        can_use, reason = self._check_skill_cost(attacker, skill_data)
        if not can_use:
            return [{
                'type': 'error',
                'message': reason
            }]
        
        # 扣除消耗
        self._consume_skill_cost(attacker, skill_data)
        
        # 应用技能效果
        results = []
        context = {
            'attacker': attacker,
            'target': target,
            'skill': skill_data
        }
        
        for effect_config in skill_data.get('effects', []):
            result = apply_effect(effect_config, attacker, target, context)
            if result:
                results.append(result)
                
                # 更新上下文（供后续效果使用）
                if result.get('type') == 'damage':
                    context['last_damage'] = result.get('value', 0)
        
        return results
    
    def _check_skill_cost(self, attacker, skill_data):
        """
        检查技能消耗
        
        Returns:
            tuple: (是否可用, 原因)
        """
        # 检查灵力消耗
        cost_qi = skill_data.get('cost_qi', 0)
        if cost_qi > 0 and attacker.ndb.qi < cost_qi:
            return False, f"灵力不足（需要{cost_qi}，当前{attacker.ndb.qi}）"
        
        # 检查生命消耗
        cost_hp = skill_data.get('cost_hp', 0)
        if cost_hp > 0 and attacker.ndb.hp <= cost_hp:
            return False, f"生命值不足以施展此技能"
        
        # 检查冷却（TODO: 需要冷却系统）
        # cooldown = skill_data.get('cooldown', 0)
        
        return True, ""
    
    def _consume_skill_cost(self, attacker, skill_data):
        """扣除技能消耗"""
        cost_qi = skill_data.get('cost_qi', 0)
        cost_hp = skill_data.get('cost_hp', 0)
        
        if cost_qi > 0:
            attacker.ndb.qi -= cost_qi
        
        if cost_hp > 0:
            attacker.ndb.hp = max(1, attacker.ndb.hp - cost_hp)
    
    def execute_combat_round(self, attacker, target):
        """
        执行一个战斗回合
        
        Args:
            attacker: 攻击者
            target: 目标
        
        Returns:
            dict: 回合结果
        """
        # 增加回合计数
        attacker.ndb.combat_round = getattr(attacker.ndb, 'combat_round', 0) + 1
        
        messages = []
        
        # 处理持续效果（DOT, Buff等）
        self._process_ongoing_effects(attacker, messages)
        self._process_ongoing_effects(target, messages)
        
        # 检查是否死亡
        if target.ndb.hp <= 0:
            return {
                'combat_end': True,
                'winner': attacker,
                'messages': messages
            }
        
        if attacker.ndb.hp <= 0:
            return {
                'combat_end': True,
                'winner': target,
                'messages': messages
            }
        
        # 攻击者行动
        skill_key = self._choose_skill(attacker)
        results = self.use_skill(attacker, target, skill_key)
        
        for result in results:
            if result.get('message'):
                messages.append(result['message'])
        
        # 检查目标是否死亡
        if target.ndb.hp <= 0:
            return {
                'combat_end': True,
                'winner': attacker,
                'messages': messages
            }
        
        # 目标反击
        counter_skill = self._choose_skill(target)
        counter_results = self.use_skill(target, attacker, counter_skill)
        
        for result in counter_results:
            if result.get('message'):
                messages.append(result['message'])
        
        # 检查攻击者是否死亡
        if attacker.ndb.hp <= 0:
            return {
                'combat_end': True,
                'winner': target,
                'messages': messages
            }
        
        # 检查最大回合数
        if attacker.ndb.combat_round >= self.max_rounds:
            return {
                'combat_end': True,
                'winner': None,  # 平局
                'messages': messages + ["战斗超时，平局"]
            }
        
        return {
            'combat_end': False,
            'messages': messages
        }
    
    def _choose_skill(self, character):
        """
        选择技能（简单AI）
        
        Args:
            character: 角色
        
        Returns:
            str: 技能key
        """
        # 获取角色可用技能
        skills = getattr(character.ndb, 'skills', ['普通攻击'])
        
        if not skills:
            return '普通攻击'
        
        # 简单策略：随机选择（可以后期扩展复杂AI）
        return random.choice(skills)
    
    def _process_ongoing_effects(self, character, messages):
        """
        处理持续效果
        
        Args:
            character: 角色
            messages: 消息列表（输出参数）
        """
        # 处理DOT
        if hasattr(character.ndb, 'dots'):
            remaining_dots = []
            for dot in character.ndb.dots:
                # 造成伤害
                damage = dot['damage']
                character.ndb.hp = max(0, character.ndb.hp - damage)
                messages.append(
                    f"{character.key} 受到持续伤害 |r{damage}|n"
                )
                
                # 减少剩余时间
                dot['remaining'] -= 1
                if dot['remaining'] > 0:
                    remaining_dots.append(dot)
            
            character.ndb.dots = remaining_dots
        
        # 处理Buff倒计时
        if hasattr(character.ndb, 'buffs'):
            remaining_buffs = []
            for buff in character.ndb.buffs:
                buff['remaining'] -= 1
                if buff['remaining'] > 0:
                    remaining_buffs.append(buff)
                else:
                    # Buff过期，移除属性加成
                    attr = buff['attribute']
                    value = buff['value']
                    current = getattr(character.ndb, attr, 0)
                    setattr(character.ndb, attr, max(0, current - value))
                    messages.append(
                        f"{character.key} 的 {attr} 加成消失"
                    )
            
            character.ndb.buffs = remaining_buffs
        
        # 处理Debuff倒计时
        if hasattr(character.ndb, 'debuffs'):
            remaining_debuffs = []
            for debuff in character.ndb.debuffs:
                debuff['remaining'] -= 1
                if debuff['remaining'] > 0:
                    remaining_debuffs.append(debuff)
                else:
                    # Debuff过期，恢复属性
                    attr = debuff['attribute']
                    value = debuff['value']
                    current = getattr(character.ndb, attr, 0)
                    setattr(character.ndb, attr, current + value)
                    messages.append(
                        f"{character.key} 的 {attr} 减益消失"
                    )
            
            character.ndb.debuffs = remaining_debuffs
    
    def calculate_combat_rewards(self, winner, loser):
        """
        计算战斗奖励
        Args:
        winner: 获胜者
        loser: 失败者
    
    Returns:
        dict: 奖励信息
    """
    # 获取基础奖励配置
    exp_per_level = get_config('combat.exp_per_enemy_level', 10)
    gold_per_level = get_config('combat.gold_per_enemy_level', 5)
    
    loser_level = getattr(loser.ndb, 'level', 1)
    
    # 计算经验
    base_exp = exp_per_level * loser_level
    exp_reward = int(base_exp * random.uniform(0.9, 1.1))
    
    # 计算金币
    base_gold = gold_per_level * loser_level
    gold_reward = int(base_gold * random.uniform(0.8, 1.2))
    
    # TODO: 处理掉落物品
    
    return {
        'exp': exp_reward,
        'gold': gold_reward,
        'items': []  # TODO: 物品掉落
    }